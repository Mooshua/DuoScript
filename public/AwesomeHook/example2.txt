struct __SourceHook_FHCls_ILoopModeLoopInit0
{
	static __SourceHook_FHCls_ILoopModeLoopInit0 ms_Inst;
	static ::SourceHook::MemFuncInfo ms_MFI;
	static ::SourceHook::IHookManagerInfo *ms_HI;
	static ::SourceHook::ProtoInfo ms_Proto;
	static int HookManPubFunc(bool store, ::SourceHook::IHookManagerInfo *hi)
	{
		using namespace ::SourceHook;
		GetFuncInfo(
				(static_cast<bool (ILoopMode::*)(KeyValues *, ILoopModePrerequisiteRegistry *)>(&ILoopMode::LoopInit)),
				ms_MFI);
		if (g_SHPtr->GetIfaceVersion() != 5)return 1;
		if (g_SHPtr->GetImplVersion() < 5)return 1;
		if (store)ms_HI = hi;
		if (hi) {
			MemFuncInfo mfi = {true, -1, 0, 0};
			GetFuncInfo(&__SourceHook_FHCls_ILoopModeLoopInit0::Func, mfi);
			hi->SetInfo(1, ms_MFI.vtbloffs, ms_MFI.vtblindex, &ms_Proto,
						reinterpret_cast<void **>(reinterpret_cast<char *>(&ms_Inst) + mfi.vtbloffs)[mfi.vtblindex]);
		}
		return 0;
	}
	typedef fastdelegate::FastDelegate<bool, KeyValues *, ILoopModePrerequisiteRegistry *> FD;
	struct IMyDelegate:: : SourceHook::ISHDelegate
	{
		virtual bool Call(KeyValues *p1, ILoopModePrerequisiteRegistry *p2) = 0;
	};
	struct CMyDelegateImpl : IMyDelegate
	{
		FD m_Deleg;
		CMyDelegateImpl(FD deleg) : m_Deleg(deleg)
		{}
		virtual~CMyDelegateImpl()
		{}
		bool Call(KeyValues *p1, ILoopModePrerequisiteRegistry *p2)
		{ return m_Deleg(p1, p2); }
		void DeleteThis()
		{ delete this; }
		bool IsEqual(ISHDelegate *pOtherDeleg)
		{ return m_Deleg == static_cast<CMyDelegateImpl *>(pOtherDeleg)->m_Deleg; }
	};;
	virtual bool Func(KeyValues *p1, ILoopModePrerequisiteRegistry *p2)
	{
		using namespace ::SourceHook;
		void *ourvfnptr = reinterpret_cast<void *>(
				*reinterpret_cast<void ***>(reinterpret_cast<char *>(this) + ms_MFI.vtbloffs) + ms_MFI.vtblindex);
		void *vfnptr_origentry;
		META_RES status = MRES_IGNORED;
		META_RES prev_res;
		META_RES cur_res;
		typedef ReferenceCarrier<bool>::type my_rettype;
		my_rettype orig_ret;
		my_rettype override_ret;
		my_rettype plugin_ret;
		IMyDelegate *iter;
		IHookContext *pContext = g_SHPtr->SetupHookLoop(ms_HI, ourvfnptr, reinterpret_cast<void *>(this),
														&vfnptr_origentry, &status, &prev_res, &cur_res, &orig_ret,
														&override_ret);
		prev_res = MRES_IGNORED;
		while ((iter = static_cast<IMyDelegate *>(pContext->GetNext()))) {
			cur_res = MRES_IGNORED;
			plugin_ret = iter->Call(p1, p2);
			prev_res = cur_res;
			if (cur_res > status)status = cur_res;
			if (cur_res >= MRES_OVERRIDE)*reinterpret_cast<my_rettype *>(pContext->GetOverrideRetPtr()) = plugin_ret;
		}
		if (status != MRES_SUPERCEDE && pContext->ShouldCallOrig()) {
			bool (EmptyClass::*mfp)(KeyValues *, ILoopModePrerequisiteRegistry *);
			reinterpret_cast<void **>(&mfp)[0] = vfnptr_origentry;;
			orig_ret = (reinterpret_cast<EmptyClass *>(this)->*mfp)(p1, p2);
		}
		else orig_ret = override_ret;
		prev_res = MRES_IGNORED;
		while ((iter = static_cast<IMyDelegate *>(pContext->GetNext()))) {
			cur_res = MRES_IGNORED;
			plugin_ret = iter->Call(p1, p2);
			prev_res = cur_res;
			if (cur_res > status)status = cur_res;
			if (cur_res >= MRES_OVERRIDE)*reinterpret_cast<my_rettype *>(pContext->GetOverrideRetPtr()) = plugin_ret;
		}
		const my_rettype *retptr = reinterpret_cast<const my_rettype *>((status >= MRES_OVERRIDE)
																		? pContext->GetOverrideRetPtr()
																		: pContext->GetOrigRetPtr());
		g_SHPtr->EndContext(pContext);
		return *retptr;;
	}
};
__SourceHook_FHCls_ILoopModeLoopInit0 __SourceHook_FHCls_ILoopModeLoopInit0::ms_Inst;
::SourceHook::MemFuncInfo __SourceHook_FHCls_ILoopModeLoopInit0::ms_MFI;
::SourceHook::IHookManagerInfo *__SourceHook_FHCls_ILoopModeLoopInit0::ms_HI;
int __SourceHook_FHAddILoopModeLoopInit(void *iface, ::SourceHook::ISourceHook::AddHookMode mode, bool post,
										__SourceHook_FHCls_ILoopModeLoopInit0::FD handler)
{
	using namespace ::SourceHook;
	MemFuncInfo mfi = {true, -1, 0, 0};
	GetFuncInfo((static_cast<bool (ILoopMode::*)(KeyValues *, ILoopModePrerequisiteRegistry *)>(&ILoopMode::LoopInit)),
				mfi);
	if (mfi.thisptroffs < 0 || !mfi.isVirtual)return false;
	return g_SHPtr->AddHook(g_PLID, mode, iface, mfi.thisptroffs, __SourceHook_FHCls_ILoopModeLoopInit0::HookManPubFunc,
							new __SourceHook_FHCls_ILoopModeLoopInit0::CMyDelegateImpl(handler), post);
}
bool __SourceHook_FHRemoveILoopModeLoopInit(void *iface, bool post, __SourceHook_FHCls_ILoopModeLoopInit0::FD handler)
{
	using namespace ::SourceHook;
	MemFuncInfo mfi = {true, -1, 0, 0};
	GetFuncInfo((static_cast<bool (ILoopMode::*)(KeyValues *, ILoopModePrerequisiteRegistry *)>(&ILoopMode::LoopInit)),
				mfi);
	__SourceHook_FHCls_ILoopModeLoopInit0::CMyDelegateImpl tmp(handler);
	return g_SHPtr->RemoveHook(g_PLID, iface, mfi.thisptroffs, __SourceHook_FHCls_ILoopModeLoopInit0::HookManPubFunc,
							   &tmp, post);
}
const ::SourceHook::PassInfo __SourceHook_ParamInfos_ILoopModeLoopInit0[] = {{1,                                       0,                                                                0},
																			 {sizeof(KeyValues *),                     ::SourceHook::GetPassInfo<KeyValues *>::type,                     ::SourceHook::GetPassInfo<KeyValues *>::flags},
																			 {sizeof(ILoopModePrerequisiteRegistry *), ::SourceHook::GetPassInfo<ILoopModePrerequisiteRegistry *>::type, ::SourceHook::GetPassInfo<ILoopModePrerequisiteRegistry *>::flags}};
const ::SourceHook::PassInfo::V2Info __SourceHook_ParamInfos2_ILoopModeLoopInit0[] = {{0, 0, 0, 0},
																					  {0, 0, 0, 0},
																					  {0, 0, 0, 0}};
::SourceHook::ProtoInfo __SourceHook_FHCls_ILoopModeLoopInit0::ms_Proto = {2, {sizeof(bool)